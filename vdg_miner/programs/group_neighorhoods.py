import os
import sys
import gzip
import pickle
import argparse
import xml.etree.ElementTree as ET

import numpy as np
import prody as pr

"""
Group neighborhoods around residues in a database of protein structures by 
their 3Di sequences, ordered by CA-CA distance to the central residue. 
Takes as input NPY files of 3Di sequences generated by main.py and outputs 
a dictionary of neighborhoods that match each unique 3Di sequence, with 
the 3Di sequence given as a tuple of ints (acting as the key) and each 
value consisting of a list of tuples, each containing the PDB file name, 
the ProDy residue index of the central residue, and the structure 
resolution.  

Requires as input a directory containing NPY files of 3Di sequences, 
grouped hierarchically according to the central two characters of the 
PDB accession code, and a directory containing validation XML files 
of each structure.  Outputs a pickled dictionary with keys and values 
as described above.
"""

resnames = ['ALA', 'CYS', 'ASP', 'GLU', 'PHE', 'GLY', 'HIS', 'ILE', 'LYS',
            'LEU', 'MET', 'ASN', 'PRO', 'GLN', 'ARG', 'SER', 'THR', 'VAL',
            'TRP', 'TYR']

def resolution_from_xml(xml_file):
    """Retrieve resolution from validation XML file.

    Parameters
    ----------
    xml_file : str
        Path to validation XML file.

    Returns
    -------
    resolution : float
        Resolution of the structure in Angstroms.
    """
    with gzip.open(xml_file, 'rb') as infile:
        tree = ET.parse(infile)
    e = tree.findall('Entry')[0].attrib
    resolution = e['PDB-resolution']
    try:
        resolution = float(resolution)
    except:
        pass
    return resolution

def parse_args():
    argp = argparse.ArgumentParser()
    argp.add_argument('npy_dir', help=('Directory containing NPY files '
                                       'of 3Di sequences.'))
    argp.add_argument('xml_dir', help='Directory containing XML files.')
    argp.add_argument('out_file', help='Output file path w/o pkl extension.')
    argp.add_argument('aa', help=('One-letter code of the amino acid for '
                                  'which to group neighborhoods.'))
    argp.add_argument('-n', '--n-neighbors', type=int, default=50, 
                      help='Number of neighbors to include.')
    return argp.parse_args()

if __name__ == "__main__":
    args = parse_args()
    subdirs = os.listdir(args.npy_dir)
    neighborhoods = {}
    for subdir in subdirs:
        npy_files = os.listdir(os.path.join(args.npy_dir, subdir))
        for npy_file in npy_files:
            try:
                if '.npy' not in npy_file:
                    continue
                pdb_id = npy_file.split('_')[0]
                biounit = '_'.join(npy_file[:-4].split('_')[:3])
                seq_file = npy_file.replace('.npy', '.seq')
                npy_path = os.path.join(args.npy_dir, subdir, npy_file)
                seq_path = os.path.join(args.npy_dir, subdir, seq_file)
                xml_file = os.path.join(args.xml_dir, subdir, pdb_id.lower(), 
                                        pdb_id.lower() + '_validation.xml.gz')
                try:
                    with open(seq_path, 'r') as f:
                        aa_seq = f.read().strip()
                    res = resolution_from_xml(xml_file)
                except:
                    continue
                npy = np.load(npy_path)[:, :args.n_neighbors]
                if len(npy) != len(aa_seq):
                    print('WARNING: Mismatched lengths for', npy_path)
                    continue
                for i, seq in enumerate(npy):
                    if aa_seq[i] != args.aa or seq[0] == 20:
                        continue # residue is not args.aa or is invalid
                    if tuple(seq) in neighborhoods:
                        neighborhoods[tuple(seq)].append((biounit, i, res))
                    else:
                        neighborhoods[tuple(seq)] = [(biounit, i, res)]
            except:
                print('Error processing', npy_file, 'in', subdir, 
                      file=sys.stderr)
    
    print('DUMPING PICKLE')
    with open(args.out_file + '_' + args.aa + '.pkl', 'wb') as f:
        pickle.dump(neighborhoods, f)

    csv_lines = []
    for val in neighborhoods.values():
        tups = [tup for tup in val if type(tup[2]) is float]
        if len(tups) == 0:
            continue
        best_res_soln = sorted(tup, key=lambda x: x[2])[0]
        csv_lines.append(','.join([str(el) for el in best_res_soln]))
    with open(args.out_file + '_' + args.aa + '.csv', 'w') as f:
        f.write('\n'.join(sorted(csv_lines)))